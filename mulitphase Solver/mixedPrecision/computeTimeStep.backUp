#include "strdata.h"
#include "eqos.h"
#include "rotateVector.h"

__device__ double computeFaceMaxSignal(INPUT *d_input, double *primVecF, double n[3], double nt1[3], double nt2[3]){

	double rhoLiquid, rhoGas, pLiquid, pGas;
	double cLiquid, cGas, cMax;
	double velGlb[3], velLcl[3];
	
	rhoLiquid = primVecF[1];
	rhoGas	  = primVecF[2];
	velGlb[0] = primVecF[3];
	velGlb[1] = primVecF[4];
	velGlb[2] = primVecF[5];
	pLiquid   = primVecF[6];
	pGas      = primVecF[7];
	
	rotateVector_glb2lcl(velGlb,velLcl,n,nt1,nt2);
	cLiquid  = eqos(d_input,0,4,rhoLiquid, pLiquid);
	cGas     = eqos(d_input,1,4,rhoGas, pGas);
	cMax     = fmax(fabs(velLcl[0])+cLiquid, fabs(velLcl[0]) + cGas);
	
	printf("rhoLiq %f pLiq %f us %f c %f\n", rhoLiquid, pLiquid, velLcl[0], cLiquid);

	return cMax;
}

__global__ void computeLocalSignalSumProx(INPUT *d_input, int nInner, int nFcs, int *fc2el, double *n, double *nt1, double *nt2, double *primVecF, double *area, double *cellSignalSum, int max, int *neigRank4fc, int *lclFc2idRcv, double *recvBuff){

	int ifc = nInner + threadIdx.x + blockIdx.x * blockDim.x;
	
	double cMax, cLeftMax, cRightMax, nVec[3], nt1Vec[3], nt2Vec[3];
	int neigRank, iProx;
	double areaF;

	cLeftMax = cRightMax = 0;
	while(ifc < nFcs){
				
		for(int idr = 0; idr < 3; idr++){
			nVec[idr] = n[ifc*3 + idr];
			nt1Vec[idr] = nt1[ifc*3 + idr];
			nt2Vec[idr] = nt2[ifc*3 + idr];
		}	
		
		cLeftMax = computeFaceMaxSignal(d_input,&primVecF[ifc*2*10 + 0*10],nVec,nt1Vec,nt2Vec);

		neigRank = neigRank4fc[ifc];
		iProx    = lclFc2idRcv[ifc];
		cRightMax = computeFaceMaxSignal(d_input,&recvBuff[neigRank*max*10 + iProx*10],nVec,nt1Vec,nt2Vec);
		
		cMax = fmax(cLeftMax, cRightMax);	

		areaF = area[ifc];
		atomicAdd(&cellSignalSum[fc2el[ifc*2+0]], cMax*areaF);

		ifc += blockDim.x*gridDim.x;
	}
	
}


__global__ void computeLocalSignalSum(INPUT *d_input, int nFcs, int *fc2el, int *boundCond, double *n, double *nt1, double *nt2, double *primVecF, double *area, double *cellSignalSum){

	int ifc = threadIdx.x + blockIdx.x * blockDim.x;
	
	double cMax, cLeftMax, cRightMax, nVec[3], nt1Vec[3], nt2Vec[3];
	int bc;
	double areaF;

	cLeftMax = cRightMax = 0;
	while(ifc < nFcs){
				
		for(int idr = 0; idr < 3; idr++){
			nVec[idr] = n[ifc*3 + idr];
			nt1Vec[idr] = nt1[ifc*3 + idr];
			nt2Vec[idr] = nt2[ifc*3 + idr];
		}	
	
	//	if(fc2el[ifc*2+0] == 29250 || fc2el[ifc*2+1] == 29250){	
		if(ifc==117048||ifc == 33758){
			cLeftMax = computeFaceMaxSignal(d_input,&primVecF[ifc*2*10 + 0*10],nVec,nt1Vec,nt2Vec);
		}

//		bc = boundCond[ifc];
//		if(bc == 0){
//			cRightMax = computeFaceMaxSignal(d_input,&primVecF[ifc*2*10 + 1*10],nVec,nt1Vec,nt2Vec);
//		}

		cMax = fmax(cLeftMax, cRightMax);	

		areaF = area[ifc];
		//if(fc2el[ifc*2+0] == 29250 || fc2el[ifc*2+1] == 29250){printf("ifc %d cMax %f sF*aF %le\n", ifc, cMax, cMax*areaF);}
		//if(ifc==33758){printf("ifc %d cMax %f sF*aF %le\n", ifc, cMax, cMax*areaF);}
		atomicAdd(           &cellSignalSum[fc2el[ifc*2+0]], cMax*areaF);
		if(bc==0){atomicAdd( &cellSignalSum[fc2el[ifc*2+1]], cMax*areaF);}

		ifc += blockDim.x*gridDim.x;
	}
	
}

__global__ void computeLocalCFL(int nElem, double *volume, double *cellSignalSum, double *blockMin){

	int tid = threadIdx.x;
	int idx = tid + blockIdx.x * blockDim.x;

	__shared__ double sData[512];
	double localMin = 1e12;

	sData[tid] = 1e9;
	while(idx < nElem){
		double val = volume[idx] / cellSignalSum[idx];
		localMin = fmin(localMin, val);
		idx += blockDim.x * gridDim.x;
	}
	
	sData[tid] = localMin;
	__syncthreads();

	for (int stride = blockDim.x/2; stride > 0; stride >>= 1){
		if (tid < stride){
			sData[tid] = fmin(sData[tid], sData[tid + stride]);
		}
		__syncthreads();
	}

	if (tid == 0){
		blockMin[blockIdx.x] = sData[0];
	}
}


void computeTimeStep(MESH *mesh, FIELD *field, COMM *comm, cudaStream_t sMain, cudaStream_t sProx){

	int nBlocks = (mesh->nElem+511)/512;
	int nInner  = mesh->nFcs-mesh->nProxTot;
	
	double *cellSignalSum;
	cudaMalloc((void**)&cellSignalSum, mesh->nElem*sizeof(double));

	double *h_blockMin, *d_blockMin;
	h_blockMin = (double*)malloc(nBlocks*sizeof(double));
	cudaMalloc((void**)&d_blockMin, nBlocks*sizeof(double));

	//WAIT STREAM FUNTIONS 
	computeLocalSignalSum<<<(mesh->nFcs+511)/512,512,0,sMain>>>(d_input, nInner, mesh->fc2el, mesh->boundCond, mesh->n, mesh->nt1, mesh->nt2, field->primVecF, mesh->area, cellSignalSum);
	
	int nProxTh = max(1,mesh->nProxTot);
	computeLocalSignalSumProx<<<(nProxTh+511)/512,512,0,sMain>>>(d_input, nInner, mesh->nFcs, mesh->fc2el, mesh->n, mesh->nt1, mesh->nt2, field->primVecF, mesh->area, cellSignalSum, comm->nProxFacesMax, comm->neigRank4fc, comm->lclFc2idRcv, comm->recvbuff);

	computeLocalCFL<<<nBlocks,512,0,sMain>>>(mesh->nElem, mesh->volume, cellSignalSum, d_blockMin);
	
	cudaStreamSynchronize(sMain);
	cudaMemcpy(h_blockMin, d_blockMin, nBlocks*sizeof(double), cudaMemcpyDeviceToHost);

	double minGlb;
	double minLcl = 1e15;
	for(int iBlock = 0; iBlock < nBlocks; iBlock++){
		minLcl = fmin(minLcl, h_blockMin[iBlock]);
	//	printf("block %d min %le\n", iBlock, h_blockMin[iBlock]);
	}

	MPI_Allreduce(&minLcl, &minGlb, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);

	input.dt = fmin(input.cfl*minGlb, input.maxDt);
	if(comm->rank == 0){printf("Time step set to %le\n", input.dt);}

	cudaFree(cellSignalSum);
	free(h_blockMin);
	cudaFree(d_blockMin);
}
